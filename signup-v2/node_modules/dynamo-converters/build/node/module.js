"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  dataToItem: true,
  deltaToExpression: true,
  itemToData: true
};
exports.itemToData = exports.deltaToExpression = exports.dataToItem = void 0;

var _now = require("./functions/now");

var _booleanItemValue = require("./guards/boolean-item-value");

var _dataArray = require("./guards/data-array");

var _dataObject = require("./guards/data-object");

var _listItemValue = require("./guards/list-item-value");

var _mapItemValue = require("./guards/map-item-value");

var _nullItemValue = require("./guards/null-item-value");

var _numberItemValue = require("./guards/number-item-value");

var _stringItemValue = require("./guards/string-item-value");

var _reservedWords = require("./reserved-words");

var _index = require("./interfaces/index");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _index2 = require("./types/index");

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    }
  });
});

/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */
// @todo This can be replaced with Object.fromEntries() once the support for Node v10 is dropped.
const fromEntries = entries => Array.from(entries).reduce((object, [property, value]) => ({ ...object,
  [property]: value
}), {});

const convertDataValue = value => {
  if (value === null) {
    return {
      NULL: true
    };
  }

  if (typeof value === 'boolean') {
    return {
      BOOL: value
    };
  }

  if (typeof value === 'number') {
    return {
      N: value.toString()
    };
  }

  if (typeof value === 'string') {
    return {
      S: value
    };
  }

  if ((0, _dataArray.isDataArray)(value)) {
    return {
      L: convertDataArray(value)
    };
  }

  if ((0, _dataObject.isDataObject)(value)) {
    return {
      M: convertDataObject(value)
    };
  }

  throw new Error('Unsupported data type');
};

const convertDataArray = array => {
  return array.map(value => convertDataValue(value));
};

const convertDataObject = object => {
  const entries = Object.entries(object).filter(([, value]) => value !== undefined).map(([key, value]) => [key, convertDataValue(value)]);
  return fromEntries(entries);
};

const isReservedWord = property => _reservedWords.RESERVED_WORDS.some(reservedWord => reservedWord === property.toUpperCase());

const illegalWordRegex = /[\s|.]/g;

const isIllegalWord = property => illegalWordRegex.test(property) || isReservedWord(property);

const createPropertyName = (property, expressionAttributeNames) => {
  let propertyName = property.replace(illegalWordRegex, '');
  let expressionAttributeName = `#${propertyName}`;

  while (expressionAttributeName in expressionAttributeNames) {
    propertyName = `${propertyName}_`;
    expressionAttributeName = `#${propertyName}`;
  }

  expressionAttributeNames[`#${propertyName}`] = property;
  return propertyName;
};

const formRemoveStatement = (property, expressionAttributeNames) => {
  if (isIllegalWord(property)) {
    const propertyName = createPropertyName(property, expressionAttributeNames);
    return `#${propertyName}`;
  }

  return property;
};

const formSetStatement = (property, value, expressionAttributeNames, expressionAttributeValues) => {
  if (isIllegalWord(property)) {
    const propertyName = createPropertyName(property, expressionAttributeNames);
    expressionAttributeValues[`:${propertyName}`] = convertDataValue(value);
    return `#${propertyName} = :${propertyName}`;
  }

  expressionAttributeValues[`:${property}`] = convertDataValue(value);
  return `${property} = :${property}`;
};

const convertItemValue = value => {
  if ((0, _booleanItemValue.isBooleanItemValue)(value)) {
    return value.BOOL;
  }

  if ((0, _listItemValue.isListItemValue)(value)) {
    return convertItemArray(value.L);
  }

  if ((0, _mapItemValue.isMapItemValue)(value)) {
    return convertItemObject(value.M);
  }

  if ((0, _numberItemValue.isNumberItemValue)(value)) {
    if (/\./.test(value.N)) {
      return parseFloat(value.N);
    }

    return parseInt(value.N, 10);
  }

  if ((0, _nullItemValue.isNullItemValue)(value)) {
    return null;
  }

  if ((0, _stringItemValue.isStringItemValue)(value)) {
    return value.S;
  }

  throw new Error('Unsupported data type');
};

const convertItemArray = array => {
  return array.map(value => convertItemValue(value));
};

const convertItemObject = object => {
  const entries = Object.entries(object).filter(([, value]) => value !== undefined).map(([key, value]) => [key, convertItemValue(value)]);
  return fromEntries(entries);
};

const dataToItem = data => {
  const created = (0, _now.now)();
  return convertDataObject({ ...data,
    created,
    modified: created
  });
};

exports.dataToItem = dataToItem;

const deltaToExpression = delta => {
  const expressionAttributeNames = {};
  const modified = (0, _now.now)();
  const expressionAttributeValues = {
    ':modified': {
      N: modified.toString()
    }
  };
  const removeStatements = [];
  const setStatements = ['modified = :modified'];
  const updateExpressions = [];

  for (const [property, value] of Object.entries(delta)) {
    if (value === undefined) {
      removeStatements.push(formRemoveStatement(property, expressionAttributeNames));
    } else if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || typeof value === 'object') {
      setStatements.push(formSetStatement(property, value, expressionAttributeNames, expressionAttributeValues));
    }
  }

  if (removeStatements.length > 0) {
    updateExpressions.push(`REMOVE ${removeStatements.join(', ')}`);
  }

  if (setStatements.length > 0) {
    updateExpressions.push(`SET ${setStatements.join(', ')}`);
  }

  return {
    expressionAttributeNames: Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,
    expressionAttributeValues,
    updateExpression: updateExpressions.join(' ')
  };
};

exports.deltaToExpression = deltaToExpression;

const itemToData = item => convertItemObject(item);

exports.itemToData = itemToData;
