import { now } from './functions/now';
import { isBooleanItemValue } from './guards/boolean-item-value';
import { isDataArray } from './guards/data-array';
import { isDataObject } from './guards/data-object';
import { isListItemValue } from './guards/list-item-value';
import { isMapItemValue } from './guards/map-item-value';
import { isNullItemValue } from './guards/null-item-value';
import { isNumberItemValue } from './guards/number-item-value';
import { isStringItemValue } from './guards/string-item-value';
import { RESERVED_WORDS } from './reserved-words';
/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */
export * from './interfaces/index';
export * from './types/index';
// @todo This can be replaced with Object.fromEntries() once the support for Node v10 is dropped.
const fromEntries = (entries) => Array.from(entries).reduce((object, [property, value]) => ({ ...object, [property]: value }), {});
const convertDataValue = (value) => {
    if (value === null) {
        return {
            NULL: true
        };
    }
    if (typeof value === 'boolean') {
        return {
            BOOL: value
        };
    }
    if (typeof value === 'number') {
        return {
            N: value.toString()
        };
    }
    if (typeof value === 'string') {
        return {
            S: value
        };
    }
    if (isDataArray(value)) {
        return {
            L: convertDataArray(value)
        };
    }
    if (isDataObject(value)) {
        return {
            M: convertDataObject(value)
        };
    }
    throw new Error('Unsupported data type');
};
const convertDataArray = (array) => {
    return array.map((value) => convertDataValue(value));
};
const convertDataObject = (object) => {
    const entries = Object.entries(object)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => [key, convertDataValue(value)]);
    return fromEntries(entries);
};
const isReservedWord = (property) => RESERVED_WORDS.some((reservedWord) => reservedWord === property.toUpperCase());
const illegalWordRegex = /[\s|.]/g;
const isIllegalWord = (property) => illegalWordRegex.test(property) || isReservedWord(property);
const createPropertyName = (property, expressionAttributeNames) => {
    let propertyName = property.replace(illegalWordRegex, '');
    let expressionAttributeName = `#${propertyName}`;
    while (expressionAttributeName in expressionAttributeNames) {
        propertyName = `${propertyName}_`;
        expressionAttributeName = `#${propertyName}`;
    }
    expressionAttributeNames[`#${propertyName}`] = property;
    return propertyName;
};
const formRemoveStatement = (property, expressionAttributeNames) => {
    if (isIllegalWord(property)) {
        const propertyName = createPropertyName(property, expressionAttributeNames);
        return `#${propertyName}`;
    }
    return property;
};
const formSetStatement = (property, value, expressionAttributeNames, expressionAttributeValues) => {
    if (isIllegalWord(property)) {
        const propertyName = createPropertyName(property, expressionAttributeNames);
        expressionAttributeValues[`:${propertyName}`] = convertDataValue(value);
        return `#${propertyName} = :${propertyName}`;
    }
    expressionAttributeValues[`:${property}`] = convertDataValue(value);
    return `${property} = :${property}`;
};
const convertItemValue = (value) => {
    if (isBooleanItemValue(value)) {
        return value.BOOL;
    }
    if (isListItemValue(value)) {
        return convertItemArray(value.L);
    }
    if (isMapItemValue(value)) {
        return convertItemObject(value.M);
    }
    if (isNumberItemValue(value)) {
        if (/\./.test(value.N)) {
            return parseFloat(value.N);
        }
        return parseInt(value.N, 10);
    }
    if (isNullItemValue(value)) {
        return null;
    }
    if (isStringItemValue(value)) {
        return value.S;
    }
    throw new Error('Unsupported data type');
};
const convertItemArray = (array) => {
    return array.map((value) => convertItemValue(value));
};
const convertItemObject = (object) => {
    const entries = Object.entries(object)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => [key, convertItemValue(value)]);
    return fromEntries(entries);
};
export const dataToItem = (data) => {
    const created = now();
    return convertDataObject({ ...data, created, modified: created });
};
export const deltaToExpression = (delta) => {
    const expressionAttributeNames = {};
    const modified = now();
    const expressionAttributeValues = { ':modified': { N: modified.toString() } };
    const removeStatements = [];
    const setStatements = ['modified = :modified'];
    const updateExpressions = [];
    for (const [property, value] of Object.entries(delta)) {
        if (value === undefined) {
            removeStatements.push(formRemoveStatement(property, expressionAttributeNames));
        }
        else if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || typeof value === 'object') {
            setStatements.push(formSetStatement(property, value, expressionAttributeNames, expressionAttributeValues));
        }
    }
    if (removeStatements.length > 0) {
        updateExpressions.push(`REMOVE ${removeStatements.join(', ')}`);
    }
    if (setStatements.length > 0) {
        updateExpressions.push(`SET ${setStatements.join(', ')}`);
    }
    return {
        expressionAttributeNames: Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,
        expressionAttributeValues,
        updateExpression: updateExpressions.join(' ')
    };
};
export const itemToData = (item) => convertItemObject(item);
//# sourceMappingURL=module.js.map